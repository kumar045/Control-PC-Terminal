#!/usr/bin/env bash
set -e

SESSION="control-terminal"
PORT=7681
INSTALL_DIR="$HOME/.control-terminal/bin"

CLOUDFLARED_BIN="cloudflared"
CLOUDFLARED_PID=""
CLOUDFLARED_LOG=""
TTYD_AUTH=""

TELEGRAM_ENABLED="0"
TELEGRAM_BOT_TOKEN=""
TELEGRAM_ALLOWED_CHAT_ID=""
TELEGRAM_BOT_PID=""
TELEGRAM_STREAM_PID=""
TELEGRAM_STREAM_CHAT_ID=""
TELEGRAM_AUTO_WATCH_SECONDS="2"
AGENT_RUNNER_SCRIPT=""

create_agent_runner_script() {
  local escaped_agent_cmd
  AGENT_RUNNER_SCRIPT="$(mktemp -t control-terminal-agent.XXXXXX.sh)"
  escaped_agent_cmd="$(printf '%q' "$AGENT_CMD")"

  cat > "$AGENT_RUNNER_SCRIPT" <<EOF
#!/usr/bin/env bash
set +e

$escaped_agent_cmd
exit_code=\$?

echo ""
echo "‚ö†Ô∏è Agent process exited with code \$exit_code. Keeping tmux session alive."
echo "You can restart the agent manually in this tmux shell."

exec bash -i
EOF

  chmod +x "$AGENT_RUNNER_SCRIPT"
}

start_agent_session() {
  create_agent_runner_script
  tmux new-session -d -s "$SESSION" "$AGENT_RUNNER_SCRIPT"
}

ensure_install_dir_on_path() {
  case ":$PATH:" in
    *":$INSTALL_DIR:"*) ;;
    *) export PATH="$INSTALL_DIR:$PATH" ;;
  esac
}

download_with_retries() {
  local url="$1"
  local target="$2"
  local attempts=0

  while [ "$attempts" -lt 3 ]; do
    attempts=$((attempts + 1))
    if curl -fL --connect-timeout 10 --retry 3 --retry-delay 2 "$url" -o "$target"; then
      return 0
    fi
    echo "Download failed (attempt $attempts/3): $url"
  done

  return 1
}

# ----------------------------------------
# Cloudflared installer
# ----------------------------------------
install_cloudflared() {
  local os arch download_url target_bin
  os="$(uname -s | tr '[:upper:]' '[:lower:]')"
  arch="$(uname -m)"
  target_bin="$INSTALL_DIR/cloudflared"

  if [ "$os" != "linux" ]; then
    echo "Automatic cloudflared install is only supported on Linux."
    return 1
  fi

  case "$arch" in
    x86_64|amd64) arch="amd64" ;;
    aarch64|arm64) arch="arm64" ;;
    *)
      echo "Unsupported architecture: $arch"
      return 1
      ;;
  esac

  download_url="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-$arch"

  mkdir -p "$INSTALL_DIR"
  ensure_install_dir_on_path

  echo "Downloading cloudflared..."
  if ! download_with_retries "$download_url" "$target_bin"; then
    echo "GitHub release download failed, trying Cloudflare package mirror..."
    download_with_retries "https://pkg.cloudflare.com/cloudflared/cloudflared-linux-$arch" "$target_bin"
  fi

  chmod +x "$target_bin"

  CLOUDFLARED_BIN="$target_bin"
}

install_ttyd() {
  local os arch ttyd_file latest_tag ttyd_url target_bin

  os="$(uname -s | tr '[:upper:]' '[:lower:]')"
  arch="$(uname -m)"
  target_bin="$INSTALL_DIR/ttyd"

  if [ "$os" != "linux" ]; then
    echo "Automatic ttyd install is only supported on Linux."
    return 1
  fi

  case "$arch" in
    x86_64|amd64) ttyd_file="ttyd.x86_64" ;;
    aarch64|arm64) ttyd_file="ttyd.aarch64" ;;
    *)
      echo "Unsupported architecture: $arch"
      return 1
      ;;
  esac

  latest_tag="$(curl -fsSL https://api.github.com/repos/tsl0922/ttyd/releases/latest \
    | awk -F'"' '/"tag_name"/ {print $4; exit}')"

  if [ -z "$latest_tag" ]; then
    echo "Could not determine latest ttyd release."
    return 1
  fi

  ttyd_url="https://github.com/tsl0922/ttyd/releases/download/${latest_tag}/${ttyd_file}"

  mkdir -p "$INSTALL_DIR"
  ensure_install_dir_on_path

  echo "Downloading ttyd ($latest_tag)..."
  download_with_retries "$ttyd_url" "$target_bin"
  chmod +x "$target_bin"
}

# ----------------------------------------
# Agent auto-detection
# ----------------------------------------
detect_codex() {
  for cmd in codex openai-codex codex-cli codex-agent; do
    if command -v "$cmd" >/dev/null 2>&1; then
      echo "$cmd"
      return 0
    fi
  done
  return 1
}

detect_claude() {
  for cmd in claude claude-cli anthropic; do
    if command -v "$cmd" >/dev/null 2>&1; then
      echo "$cmd"
      return 0
    fi
  done
  return 1
}

prompt_ttyd_auth() {
  local username password

  while true; do
    read -r -p "Set web terminal username (leave blank to skip auth): " username
    if [ -z "$username" ]; then
      TTYD_AUTH=""
      echo "‚ÑπÔ∏è Web terminal auth disabled."
      return 0
    fi

    read -r -s -p "Set web terminal password: " password
    echo ""

    if [ -z "$password" ]; then
      echo "Password cannot be empty when username is set. Try again."
      continue
    fi

    TTYD_AUTH="${username}:${password}"
    echo "‚úÖ Web terminal auth enabled for user '$username'."
    return 0
  done
}

prompt_telegram_config() {
  local enable_telegram

  read -r -p "Enable Telegram bot control for this session? (y/N): " enable_telegram
  if [[ ! "$enable_telegram" =~ ^[Yy]$ ]]; then
    return 0
  fi

  read -r -p "Enter Telegram bot token (from @BotFather): " TELEGRAM_BOT_TOKEN
  if [ -z "$TELEGRAM_BOT_TOKEN" ]; then
    echo "‚ö†Ô∏è Token empty. Telegram control disabled."
    return 0
  fi

  read -r -p "Enter allowed Telegram chat_id (required): " TELEGRAM_ALLOWED_CHAT_ID
  if [ -z "$TELEGRAM_ALLOWED_CHAT_ID" ]; then
    echo "‚ö†Ô∏è chat_id empty. Telegram control disabled."
    TELEGRAM_BOT_TOKEN=""
    return 0
  fi

  TELEGRAM_ENABLED="1"
  echo "‚úÖ Telegram control enabled for chat_id=$TELEGRAM_ALLOWED_CHAT_ID"
}

telegram_send_message() {
  local chat_id="$1"
  local text="$2"
  local max_len=3800

  if [ "${#text}" -gt "$max_len" ]; then
    text="${text:0:$max_len}"$'\n\n...(truncated)'
  fi

  curl -fsS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
    --data-urlencode "chat_id=${chat_id}" \
    --data-urlencode "text=${text}" >/dev/null || true
}

telegram_tail_output() {
  local lines="$1"
  tmux capture-pane -t "$SESSION" -p | tail -n "$lines"
}

is_process_descendant_matching() {
  local root_pid="$1"
  local expected_cmd="$2"
  local queue current children comm

  queue="$root_pid"
  while [ -n "$queue" ]; do
    current="${queue%% *}"
    if [ "$queue" = "$current" ]; then
      queue=""
    else
      queue="${queue#* }"
    fi

    comm="$(ps -o comm= -p "$current" 2>/dev/null | awk '{print $1}' || true)"
    if [ "$comm" = "$expected_cmd" ]; then
      return 0
    fi

    children="$(pgrep -P "$current" 2>/dev/null | paste -sd' ' - || true)"
    if [ -n "$children" ]; then
      if [ -n "$queue" ]; then
        queue="$queue $children"
      else
        queue="$children"
      fi
    fi
  done

  return 1
}

ensure_agent_accepting_prompts() {
  # 1. Simple check: Does the tmux session exist?
  if ! tmux has-session -t "$SESSION" 2>/dev/null; then
    return 1
  fi
  
  # REMOVED: The complex PID detection logic that was causing the restart loop.
  # We assume if the session exists, the agent is there (or the runner script is handling it).
  
  return 0
}

stop_telegram_stream() {
  if [ -n "$TELEGRAM_STREAM_PID" ]; then
    kill "$TELEGRAM_STREAM_PID" >/dev/null 2>&1 || true
    TELEGRAM_STREAM_PID=""
    TELEGRAM_STREAM_CHAT_ID=""
  fi
}

start_telegram_stream() {
  local chat_id="$1"
  local interval="$2"

  (
    local previous current
    previous=""
    telegram_send_message "$chat_id" "‚ñ∂Ô∏è Live stream started (about every ${interval}s). Use /unwatch to stop."
    while true; do
      current="$(telegram_tail_output 40)"
      [ -z "$current" ] && current="(no output yet)"
      if [ "$current" != "$previous" ]; then
        local msg
        msg="$(printf "üì° %s live view:\n%s" "$SESSION" "$current")"
        telegram_send_message "$chat_id" "$msg"
        previous="$current"
      fi
      sleep "$interval"
    done
  ) &

  TELEGRAM_STREAM_PID=$!
  TELEGRAM_STREAM_CHAT_ID="$chat_id"
}

ensure_telegram_stream_for_chat() {
  local chat_id="$1"

  if [ -n "$TELEGRAM_STREAM_PID" ] && kill -0 "$TELEGRAM_STREAM_PID" >/dev/null 2>&1; then
    if [ "$TELEGRAM_STREAM_CHAT_ID" = "$chat_id" ]; then
      return 0
    fi
    stop_telegram_stream
  fi

  start_telegram_stream "$chat_id" "$TELEGRAM_AUTO_WATCH_SECONDS"
}

telegram_process_message() {
  local chat_id="$1"
  local text="$2"
  local response lines prompt_text

  if [ "$chat_id" != "$TELEGRAM_ALLOWED_CHAT_ID" ]; then
    telegram_send_message "$chat_id" "Unauthorized chat_id."
    return 0
  fi

  case "$text" in
    /start|/help)
      # use printf to interpret the \n as real new lines
      response="$(printf "Control-Terminal bot commands:\n/status\n/tail [n]\n/watch [seconds]\n/unwatch\n/interrupt\n/prompt <text>\nAny plain text will be sent as prompt to %s." "$SESSION")"
      telegram_send_message "$chat_id" "$response"
      ;;
    /status)
      if tmux has-session -t "$SESSION" 2>/dev/null; then
        response="‚úÖ Session '$SESSION' is running."
      else
        response="‚ùå Session '$SESSION' is not running."
      fi
      telegram_send_message "$chat_id" "$response"
      ;;
    /interrupt)
      tmux send-keys -t "$SESSION" C-c
      telegram_send_message "$chat_id" "‚õî Sent Ctrl+C to session '$SESSION'."
      ;;
    /watch* )
      lines="${text#"/watch"}"
      lines="${lines// /}"
      if [[ -z "$lines" || ! "$lines" =~ ^[0-9]+$ ]]; then
        lines="$TELEGRAM_AUTO_WATCH_SECONDS"
      fi
      if [ "$lines" -lt 1 ]; then
        lines=1
      fi
      if [ "$lines" -gt 10 ]; then
        lines=10
      fi

      stop_telegram_stream
      start_telegram_stream "$chat_id" "$lines"
      ;;
    /unwatch)
      if [ -n "$TELEGRAM_STREAM_PID" ] && kill -0 "$TELEGRAM_STREAM_PID" >/dev/null 2>&1; then
        stop_telegram_stream
        telegram_send_message "$chat_id" "‚èπÔ∏è Live stream stopped."
      else
        telegram_send_message "$chat_id" "‚ÑπÔ∏è Live stream is not running."
      fi
      ;;
    /tail* )
      lines="${text#"/tail"}"
      lines="${lines// /}"
      if [[ -z "$lines" || ! "$lines" =~ ^[0-9]+$ ]]; then
        lines=40
      fi
      if [ "$lines" -gt 200 ]; then
        lines=200
      fi
      response="$(telegram_tail_output "$lines")"
      [ -z "$response" ] && response="(no output yet)"
      telegram_send_message "$chat_id" "$response"
      ;;
    /prompt*)
      prompt_text="${text#"/prompt"}"
      prompt_text="${prompt_text# }"
      if [ -z "$prompt_text" ]; then
        telegram_send_message "$chat_id" "Usage: /prompt your instruction"
        return 0
      fi
      if ! ensure_agent_accepting_prompts; then
        telegram_send_message "$chat_id" "‚ùå Session '$SESSION' is not running. Start control-terminal first."
        return 0
      fi
      # Send the text
      # --- START OF FIX ---
      # 1. Type the prompt text
      tmux send-keys -t "$SESSION" -l "$prompt_text"
      
      # 2. Wait 0.5s for text to register
      sleep 0.5
      
      # 3. Press Enter explicitly
      tmux send-keys -t "$SESSION" Enter
      
      # 4. Wait 3s for the agent to start generating a response
      sleep 3
      # --- END OF FIX ---
      response="$(telegram_tail_output 30)"
      [ -z "$response" ] && response="Prompt sent."
      telegram_send_message "$chat_id" "$response"
      ensure_telegram_stream_for_chat "$chat_id"
      ;;
    *)
      if ! ensure_agent_accepting_prompts; then
        telegram_send_message "$chat_id" "‚ùå Session '$SESSION' is not running. Start control-terminal first."
        return 0
      fi
      # Send the text
      tmux send-keys -t "$SESSION" -l "$text"
      
      # Wait for the terminal to register the text
      sleep 0.5
      
      # Send the ENTER key explicitly
      tmux send-keys -t "$SESSION" Enter
      
      # Wait longer for the AI to actually generate a response before capturing output
      sleep 3
      response="$(telegram_tail_output 30)"
      [ -z "$response" ] && response="Prompt sent."
      telegram_send_message "$chat_id" "$response"
      ensure_telegram_stream_for_chat "$chat_id"
      ;;
  esac
}

start_telegram_bot() {
  local api_url offset response parsed

  if [ "$TELEGRAM_ENABLED" != "1" ]; then
    return 0
  fi

  api_url="https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}"
  offset=0

  # warm-up: if the bot token is invalid, this will fail and disable bridge.
  if ! curl -fsS "${api_url}/getMe" >/dev/null 2>&1; then
    echo "‚ö†Ô∏è Telegram getMe failed. Disabling Telegram control."
    TELEGRAM_ENABLED="0"
    return 0
  fi

  echo "ü§ñ Telegram bridge is running. Send prompts to your bot from chat_id=$TELEGRAM_ALLOWED_CHAT_ID"

  while true; do
    response="$(curl -fsS "${api_url}/getUpdates?timeout=30&offset=${offset}" || true)"
    if [ -z "$response" ]; then
      sleep 2
      continue
    fi

    parsed="$(python3 - "$response" <<'PY'
import json
import sys

raw = sys.argv[1]
try:
    data = json.loads(raw)
except Exception:
    print("")
    raise SystemExit

for item in data.get("result", []):
    uid = item.get("update_id")
    msg = item.get("message") or {}
    chat = (msg.get("chat") or {}).get("id")
    text = msg.get("text")
    if uid is None:
      continue
    if chat is None:
      continue
    if text is None:
      text = ""
    text = text.replace("\n", " ")
    print(f"{uid}\t{chat}\t{text}")
PY
)"

    [ -z "$parsed" ] && continue

    while IFS=$'\t' read -r update_id chat_id text; do
      [ -z "$update_id" ] && continue
      offset=$((update_id + 1))
      telegram_process_message "$chat_id" "$text"
    done <<< "$parsed"
  done
}

# ----------------------------------------
# Cleanup
# ----------------------------------------
cleanup() {
  stop_telegram_stream
  if [ -n "$CLOUDFLARED_PID" ]; then
    kill "$CLOUDFLARED_PID" >/dev/null 2>&1 || true
  fi
  if [ -n "$CLOUDFLARED_LOG" ] && [ -f "$CLOUDFLARED_LOG" ]; then
    rm -f "$CLOUDFLARED_LOG"
  fi
  if [ -n "$TELEGRAM_BOT_PID" ]; then
    kill "$TELEGRAM_BOT_PID" >/dev/null 2>&1 || true
  fi
  if [ -n "$AGENT_RUNNER_SCRIPT" ] && [ -f "$AGENT_RUNNER_SCRIPT" ]; then
    rm -f "$AGENT_RUNNER_SCRIPT"
  fi
}
trap cleanup EXIT

# ----------------------------------------
# UI
# ----------------------------------------
echo ""
echo "Welcome to Control-Terminal ‚Äî AI Agent Launcher"
echo ""

CODEX_BIN="$(detect_codex 2>/dev/null || true)"
CLAUDE_BIN="$(detect_claude 2>/dev/null || true)"

echo "Choose which agent to run:"
echo "1) codex   ${CODEX_BIN:+($CODEX_BIN)}${CODEX_BIN:- (not installed)}"
echo "2) claude  ${CLAUDE_BIN:+($CLAUDE_BIN)}${CLAUDE_BIN:- (not installed)}"
echo "3) other"

read -r -p "Enter choice [1-3]: " choice

case "$choice" in
  1)
    if [ -z "$CODEX_BIN" ]; then
      echo "‚ùå Codex not found in PATH."
      exit 1
    fi
    AGENT_CMD="$CODEX_BIN"
    ;;
  2)
    if [ -z "$CLAUDE_BIN" ]; then
      echo "‚ùå Claude not found in PATH."
      exit 1
    fi
    AGENT_CMD="$CLAUDE_BIN"
    ;;
  3)
    read -r -p "Enter custom agent command: " AGENT_CMD
    if ! command -v "$AGENT_CMD" >/dev/null 2>&1; then
      echo "‚ùå Command '$AGENT_CMD' not found"
      exit 1
    fi
    ;;
  *)
    echo "Invalid choice"
    exit 1
    ;;
esac

if [ -z "$TTYD_AUTH" ]; then
  read -r -p "Configure web terminal username/password now? (y/N): " set_auth_late
  if [[ "$set_auth_late" =~ ^[Yy]$ ]]; then
    prompt_ttyd_auth
  fi
fi

echo ""
read -r -p "Expose terminal on a public address via Cloudflare Tunnel? (y/N): " expose_public

if [[ "$expose_public" =~ ^[Yy]$ ]] && [ -z "$TTYD_AUTH" ]; then
  echo "Public URL selected. Username/password is strongly recommended."
  read -r -p "Set web terminal username/password before continuing? (Y/n): " set_auth_for_public
  if [[ ! "$set_auth_for_public" =~ ^[Nn]$ ]]; then
    prompt_ttyd_auth
  fi
fi

prompt_telegram_config

LAUNCH_WEB_TERMINAL="1"
if [ "$TELEGRAM_ENABLED" = "1" ]; then
  read -r -p "Launch web terminal too? (Y/n): " launch_web_choice
  if [[ "$launch_web_choice" =~ ^[Nn]$ ]]; then
    LAUNCH_WEB_TERMINAL="0"
  fi
fi

# ----------------------------------------
# Start tmux session
# ----------------------------------------
echo ""
echo "Preparing tmux session '$SESSION' for agent '$AGENT_CMD'..."

ensure_install_dir_on_path

if tmux has-session -t "$SESSION" 2>/dev/null; then
  echo "‚ÑπÔ∏è Session '$SESSION' already exists."
  read -r -p "Reuse existing session (r) or restart with selected agent (R default): " session_action
  if [[ "$session_action" =~ ^[r]$ ]]; then
    echo "Reusing existing session without changing running agent command."
  else
    tmux kill-session -t "$SESSION"
    start_agent_session
  fi
else
  start_agent_session
fi

if [ "$TELEGRAM_ENABLED" = "1" ]; then
  start_telegram_bot &
  TELEGRAM_BOT_PID=$!
fi

# ----------------------------------------
# Cloudflare Tunnel
# ----------------------------------------
if [[ "$expose_public" =~ ^[Yy]$ ]] && [ "$LAUNCH_WEB_TERMINAL" = "1" ]; then
  if ! command -v "$CLOUDFLARED_BIN" >/dev/null 2>&1; then
    echo "cloudflared not found. Installing..."
    install_cloudflared || echo "‚ö†Ô∏è Cloudflared install failed"
  fi

  if command -v "$CLOUDFLARED_BIN" >/dev/null 2>&1; then
    CLOUDFLARED_LOG="$(mktemp -t control-terminal-cloudflared.XXXXXX.log)"
    "$CLOUDFLARED_BIN" tunnel --url "http://localhost:$PORT" --no-autoupdate \
      >"$CLOUDFLARED_LOG" 2>&1 &
    CLOUDFLARED_PID=$!

    for _ in {1..30}; do
      PUBLIC_URL="$(grep -Eo 'https://[a-zA-Z0-9.-]+\.trycloudflare\.com' "$CLOUDFLARED_LOG" | head -n 1 || true)"
      if [ -n "$PUBLIC_URL" ]; then
        echo "üåç Public URL: $PUBLIC_URL"
        break
      fi
      sleep 0.5
    done

    if [ -z "$PUBLIC_URL" ]; then
      echo "‚ö†Ô∏è Tunnel started, but URL not detected yet"
      echo "Check logs: $CLOUDFLARED_LOG"
    fi
  fi
fi

# ----------------------------------------
# ttyd or local attach
# ----------------------------------------
if [ "$LAUNCH_WEB_TERMINAL" = "1" ]; then
  echo ""
  echo "Launching ttyd web terminal on:"
  echo "üëâ http://localhost:$PORT"
  echo ""

  if ! command -v ttyd >/dev/null 2>&1; then
    echo "ttyd not found. Installing..."
    install_ttyd || {
      echo "‚ùå Failed to install ttyd. Run install.sh or install ttyd manually."
      exit 1
    }
  fi

  TTYD_ARGS=(-W -p "$PORT")
  if [ -n "$TTYD_AUTH" ]; then
    TTYD_ARGS+=(-c "$TTYD_AUTH")
  fi

  exec ttyd "${TTYD_ARGS[@]}" tmux attach -t "$SESSION"
fi

echo ""
echo "‚ÑπÔ∏è Web terminal disabled. Telegram bridge is active for remote prompts."
echo "   To watch locally, run: tmux attach -t $SESSION"

if [ -n "$TELEGRAM_BOT_PID" ]; then
  wait "$TELEGRAM_BOT_PID"
else
  tmux attach -t "$SESSION"
fi
